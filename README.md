# <img src="logo.png" alt="UMKA Logo" width="60" height="75" style="vertical-align: middle;"> <span style="font-size: 2em; vertical-align: middle; color: ">UMKA</span>


Минималистичный императивный язык программирования со статической типизацией, включающий виртуальную
машину со сборщиком мусора и JIT-компилятором.

## Особенности

- **Простой синтаксис** - легкий для разбора и понимания
- **Стековая виртуальная машина** - эффективная байткод-интерпретация
- **Автоматическое управление памятью** - сборщик мусора Mark-and-Sweep
- **JIT-компиляция** - оптимизация "горячего" кода во время выполнения

## 1. Составляющие:

#### **UMKA-P** - Парсер

**Назначение:** Преобразование исходного кода в структурированное представление

**Процесс обработки:**

- Получает на вход текстовый файл с исходным кодом на языке UMKA
- Разбивает текст программы на базовые элементы (токены) - ключевые слова, идентификаторы, числа,
  операторы
- Строит древовидную структуру (AST) согласно грамматическим правилам языка
- Проверяет семантическую корректность: соответствие типов, область видимости переменных
- Выдает готовое абстрактное синтаксическое дерево для дальнейшей компиляции

#### **UMKA-C** - Компилятор

**Назначение:** Трансляция структурированного представления в исполняемый байткод

**Процесс обработки:**

- Получает на вход абстрактное синтаксическое дерево от парсера
- Преобразует дерево в последовательность низкоуровневых инструкций байткода
- Формирует готовый байткод для выполнения в виртуальной машине

#### **UMKA-VM** - Виртуальная машина

**Назначение:** Выполнение скомпилированного байткода программы

**Процесс обработки:**

- Получает на вход байткод от компилятора
- Интерпретирует инструкции байткода последовательно, эмулируя работу процессора
- Управляет памятью программы: выделение и освобождение объектов в куче
- Реализует автоматическое управление памятью посредством сборщика мусора (Garbage Collector)
- Собирает статистику выполнения для идентификации часто используемых участков кода
- Обеспечивает выполнение встроенных функций

#### **UMKA-JIT** - JIT-компилятор

**Назначение:** Динамическая компиляция "горячих" участков кода в машинный код

**Процесс обработки:**

- Анализирует статистику выполнения, собираемую виртуальной машиной
- Выявляет часто выполняемые функции и циклы для оптимизации
- Преобразует байткод в промежуточное представление, удобное для анализа
- Применяет серию оптимизаций к промежуточному представлению
- Генерирует высокоэффективный машинный код для идентифицированных участков
- Обеспечивает переход на выполнение сгенерированного машинного кода

## 2. Типы данных
| Тип      | Описание                  | Пример                            |
|----------|---------------------------|-----------------------------------|
| `int`    | Целое число (64-битное)   | `42`, `-10`, `0`                  |
| `double` | Дробное число (64-битное) | `2.8`, `-1.118`                   |
| `string` | Строка UTF-8              | `"hello"`, `"test"`               |
| `bool`   | Логический тип            | `true`, `false`                   |
| `[]`     | Массив элементов          | `[1, 2, "a"]`, `["a", [1, 2, 3]]` |
| `unit`   | Отсутствие значения       | `return;`                         |

## 3. Синтаксис
[TODO пунктом 3.12 описать использование классов]

#### 3.1 Переменные

```
let x = 10;
let f = 0.1; // f = 1. и f = .1 запрещено
let text = "hello";
let flag = true;
let arr = [1, 2, 3];
let none = unit;
```

#### 3.2 Присваивание

```
x = 28;
name = "aboba";
arr[0] = 14; // запрещено
set(arr, 0, 14);
```

#### 3.3 Арифметика
[TODO надо ли описать унарные +/-]
```
let add = 5 + 3;   // сложение
let diff = 8 - 2;  // вычитание
let mult = 6 * 8;  // умножение
let div = 4 / 2;   // деление
let mod = 17 % 5;  // взятие остатка
```

#### 3.4 Сравнения

```
let x = 10 > 5;                 // true
let y = 10 == 10;               // true  
let z = "hi" != "bye";          // true
let w = [1, 2, 3] == [1, 2, 3]; // true
```

#### 3.5 Логические операции
```
let x = true && false;  // false
let y = true || false;  // true
let z = !true;          // false
```

#### 3.6 Условные операторы
```
if (x > 10) {
    print("ok");
} else {
    print("not ok");
}
```

#### 3.7 Циклы
```
let i = 0;
while (i < 3) {
    print(i);
    i = i + 1;
}

for (let j = 0; j < 3; j = j + 1) {
    print(j);
}
```

#### 3.8 Массивы
```
let arr = [1, 2, 4];
add(arr, 5);
for (let i = 0; i < len(arr); i = i + 1) {
    print(get(arr, i));
}
remove(arr, 1);
set(arr, 0, 10);
```

#### 3.9 Функции
```
fun fib(n) -> int {
    if (n <= 1) {
        return 0;
    }
    return fib(n - 1) + fib(n - 2);
}

fun printHello() -> unit {
    print("Hello!");
}
```

#### 3.10 Встроенные функции
```
let word = input();              // ввод с консоли
print("aboba")                   // вывод в консоль
let arr_length = len(arr);       // взятие длины
add(arr, elem);                  // добавление в массив
remove(arr, index);              // удаление из массива
let elem = get(arr, index);      // получение из массива
set(arr, index, elem);           // установка в массив по индексу
let s = str(123);                // конвертация в строку
write("filename", s);            // запись в файл
let lines = read("filename");    // чтение из файла
let double_num = to_double(42);  // конвертация в double
let int_num = to_int(3.14);      // конвертация в int
let double_num = random();       // получение рандомного double
assert(2 > 1);                   // проверка условия в runtime
```


#### 3.11 Комментарии
```
// using double slash
```

#### 3.12 Список зарезервированных слов
* `let` - объявление переменной
* `fun` - объявление функции
* `class` - объявление класса
* `method` объявление метода
* `if` - условный оператор
* `else` - альтернатива условным оператору
* `while` - цикл while
* `for` - цикл for
* `return` - возврат из функции
* `input` - ввод с консоли
* `print` - вывод в консоль
* `read` - чтение из файла
* `write` - запись в файл
* `len` - взятие длины массива
* `get` - получение из массива по индексу
* `set` - смена значения в массиве по индексу
* `add` - добавление в массив
* `remove` - удаление из массива по индексу
* `str` - конвертация в строку
* `to_double` - конвертация в double
* `to_int` - конвертация в int
* `random` - получение случайного числа
* `assert` - проверка условия 

#### 3.13 Классы
```
class Cat {
    let name = "Aboba";
}

method Cat say_hello(self) -> unit {
    print(self:name + " says: Meow!");
    return;
}

fun main() -> unit {
    let my_cat = Cat;
    my_cat$say_hello();
    return;
}
```
## 4. Грамматика EBNF
[TODO обновить грамматику]

```ebnf
(======= Программа =========)
program = { statement } ;

(======== Операторы ========)
statement = let_statement ";"
            | assignment_statement ";"
            | expression_statement ";"
            | if_statement
            | while_statement
            | for_statement
            | return_statement ";"
            | block_statement
            | function_definition
            | class_definition
            | method_definition ;

let_statement = "let", identifier, "=", expression ;

assignment_statement = identifier, "=", expression
                     | identifier, ":", identifier, "=", expression ;

expression_statement = expression ;
return_statement = "return", [ expression ] ;
block_statement = "{", { statement }, "}" ;

(========== Управляющие конструкции ==========)
if_statement = "if", "(", expression, ")", block_statement, [ "else", block_statement ] ;
while_statement = "while", "(", expression, ")", block_statement ;
for_statement = "for", "(", let_statement, ";", expression, ";", assignment_statement, ")", block_statement ;

(===== Выражения =====)
expression = cat_expression ;
cat_expression = logical_expression, { "^-^", logical_expression } ;

logical_expression = logical_or ;
logical_or = logical_and, { "||", logical_and } ;
logical_and = logical_comparison, { "&&", logical_comparison } ;
logical_comparison = comparison | "!", logical_comparison ;

comparison = arithmetic_expression, [ ("==" | "!=" | ">" | "<" | ">=" | "<="), arithmetic_expression ]
           | string_literal, "==", string_literal ;

arithmetic_expression = term ;
term = factor, { ("+" | "-"), factor } ;
factor = unary_arithmetic, { ("*" | "/" | "%"), unary_arithmetic } ;
unary_arithmetic = [ ("+" | "-") ], arithmetic_primary ;
arithmetic_primary = postfix ;

postfix = primary, { ( ":", identifier ) | ( "$", identifier, "(", [ argument_list ], ")" ) } ;
primary = integer
        | double
        | string_literal
        | boolean
        | "unit"
        | member_access
        | method_call
        | identifier
        | array_literal
        | function_call
        | "(", expression, ")" ;

(===== Доступ к полям и методам =====)
member_access = identifier, ":", identifier ;
method_call = identifier, "$", identifier, "(", [ argument_list ], ")" ;

(===== Функции =====)
function_definition = "fun", identifier, "(", [ parameter_list ], ")", "->", return_type, block_statement ;
parameter_list = identifier, { ",", identifier } ;
return_type = basic_type | array_type | identifier ;
basic_type = "int" | "double" | "string" | "bool" | "unit" ;
array_type = "[", "]" ;
function_call = identifier, "(", [ argument_list ], ")" ;
argument_list = expression, { ",", expression } ;

(===== Классы и методы =====)
class_definition = "class", identifier, "{", class_body, "}" ;
class_body = { let_statement, ";" } ;
method_definition = "method", identifier, identifier, "(", [ parameter_list ], ")", "->", return_type, block_statement ;

(===== Массивы =====)
array_literal = "[", [ expression_list ], "]" ;
expression_list = expression, { ",", expression } ;

(======= Базовые типы =========)
integer = digit, { digit } ;
double = digit, { digit }, ".", digit, { digit } ;
string_literal = '"', { string_character }, '"' ;
boolean = "true" | "false" ;
identifier = (letter | "_"), {letter | digit | "_"} ;

(======= Базовые символы =======)
letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
        | "H" | "I" | "J" | "K" | "L" | "M" | "N"
        | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
        | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
        | "c" | "d" | "e" | "f" | "g" | "h" | "i"
        | "j" | "k" | "l" | "m" | "n" | "o" | "p"
        | "q" | "r" | "s" | "t" | "u" | "v" | "w"
        | "x" | "y" | "z" ;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
string_character = ? все символы кроме '"' ? ;
```

## 5. Байткод
[TODO исправить существующие примеры байт кода]  
[TODO добавить пример байт кода при работе с классами]
* Виртуальная машина использует **стековую** архитектуру.  
* Каждая инструкция имеет вид: `[opcode - 1B][operands...]`. Типы данных для операндов: `int64`
* Все числа записываются в **Little Endian**
* Все строки записываются в кодировке **UTF-8**
* Компилятор создаёт таблицу констант вида:

  | Type  | Value  |
  |:-----:|:------:|

  Типы записей в таблицу констант: `int64` - 0x01, `double` - 0x02, `string` - 0x03, `unit` - 0x04
* Компилятор создаёт таблицу функций вида:

   | CodeOffsetBeg  |      CodeOffsetEnd      | ArgCount  | LocalCount |
   |:--------------:|:-----------------------:|:---------:|:----------:|

  Где: 
    - `CodeOffset` — смещение (`int64`) в секции байткода, с которого начинается тело функции
    - `ArgCount` — количество аргументов функции (`int64`)
    - `LocalCount` — количество локальных переменных, включая аргументы (`int64`)
* Компилятор создаёт таблицу виртуальных методов вида:

  | ClassID | MethodID |  FunctionID  |
  |:-------:|:--------:|:------------:|

  Где:
    - `ClassID` — уникальный идентификатор класса (`int64`)
    - `MethodID` — уникальный идентификатор метода, глобальный для всех классов (`int64`)
    - `FunctionID` — индекс функции в таблице функций (`int64`)

* Компилятор создаёт таблицу виртуальных полей вида: 

  | ClassID | FieldID | FieldIndex |
  |:-------:|:-------:|:----------:|

  Где:
    - `ClassID` — уникальный идентификатор класса (`int64`)
    - `FieldID` — уникальный идентификатор поля, глобальный для всех классов (`int64`)
    - `FieldIndex` — индекс поля в массиве экземпляра объекта (`int64`)
### Описание 

| Инструкция         | Код    | Операнды            | Описание                                                                                  |
|--------------------|--------|---------------------|-------------------------------------------------------------------------------------------|
| **PUSH_CONST**     | `0x01` | `int64` const_index | помещает значение из таблицы констант на стек                                             |
| **POP**            | `0x02` | -                   | удалить первое значение со стека                                                          |
| **STORE**          | `0x03` | `int64` var_index   | сохраняет первый элемент в переменную по индексу и удаляет его со стека                   |
| **LOAD**           | `0x04` | `int64` var_index   | загружает переменную по индексу на стек                                                   |
| **ADD**            | `0x10` | -                   | left + right                                                                              |
| **SUB**            | `0x11` | -                   | left - right                                                                              |
| **MUL**            | `0x12` | -                   | left * right                                                                              |
| **DIV**            | `0x13` | -                   | left / right                                                                              |
| **REM**            | `0x14` | -                   | left % right                                                                              |
| **NOT**            | `0x17` | -                   | инвертирует первое логическое значение                                                    |
| **AND**            | `0x18` | -                   | применяет логическое И к первому и второму значению                                       |
| **OR**             | `0x19` | -                   | применяет логическое ИЛИ к первому и второму значению                                     |
| **EQ**             | `0x1A` | -                   | проверяет, что первое и второе значение равны                                             |
| **NEQ**            | `0x1B` | -                   | проверяет, что первое и второе значение не равны                                          |
| **GT**             | `0x1C` | -                   | left > right                                                                              |
| **LT**             | `0x1D` | -                   | left < right                                                                              |
| **GTE**            | `0x1E` | -                   | left >= right                                                                             |
| **LTE**            | `0x1F` | -                   | left <= right                                                                             |
| **JMP**            | `0x20` | `int64` offset      | безусловный переход на offset инструкций                                                  |
| **JMP_IF_FALSE**   | `0x21` | `int64` offset      | условный переход если первое значение `false`                                             |
| **JMP_IF_TRUE**    | `0x22` | `int64` offset      | условный переход если первое значение `true`                                              |
| **CALL**           | `0x23` | `int64` func_index  | вызывает функцию по func_index                                                            |
| **RETURN**         | `0x24` | -                   | возвращает управление из функции, может брать возвращаемое значение с вершины стека       |
| **BUILD_ARR**      | `0x30` | `int64` const_index | создает массив, беря количество элементов по const_index, а сами элементы с вершины стека |
| **OPCOT**          | `0x40` | -                   | проверяет, является ли переменная unit типом                                              |
| **CALL_METHOD**    | `0x50` | `int64` meth_index  | вызывает метод класса по индексу meth_index                                               |
| **GET_FIELD**      | `0x51` | `int64` field_index | получает поле класса по индексу field_index                                               |
| **TO_STRING**      | `0x60` | -                   | конвертирует первое значение в строку                                                     |
| **TO_DOUBLE**      | `0x61` | -                   | конвертирует первое на стеке значение в число с плавающей точкой                          |
| **TO_INT**         | `0x62` | -                   | конвертирует первое на стеке значение в целое число                                       |


### Примеры

#### Пример №1

**Код UMKA**
```kt
fun main() -> unit {
    let x = 10;
    let y = 5;
    let z = x + y;
    print(z);
    return;
}
```

**Текстовый байткод**
```kt
PUSH_CONST 0
STORE 0        ; x = 10
PUSH_CONST 1
STORE 1        ; y = 5
LOAD 0
LOAD 1
ADD
STORE 2        ; z = x + y
LOAD 2
CALL 0         ; вызов стандартной функции print(z)
RETURN
```
**Бинарный код**

```kt
```

#### Пример №2

**Код UMKA**
```kt
fun main() -> unit {
    let i = 0;
    while (i < 3) {
        print(i);
        i = i + 1;
    }
    return;
}
```

**Текстовый байткод (с метками)**
```kt
PUSH_CONST 0
STORE 0          ; i = 0

L0:
LOAD 0
PUSH_CONST 1
LT
JMP_IF_FALSE L1

LOAD 0
CALL 0           ; print(i)
LOAD 0
PUSH_CONST 2
ADD
STORE 0
JMP L0

L1:
RETURN
```
**Бинарный код**
```kt

```
#### Пример №3
**Код UMKA**
```kt
fun processAndSave(arr) -> unit {
    set(arr, 0, 10);     
    add(arr, 4);          
    print(get(arr, 1));   
    remove(arr, 1);
    let total = get(arr, 0) + get(arr, 1);
    write_file("out.txt", to_string(total));
    return;
}

fun main() -> unit {
    let arr = [1,2,3];
    processAndSave(arr);
    print(17 % 5);
    print(read_file("out.txt"));
    return;
}

```
**Текстовый байткод (с метками)**
```kt
; processAndSave
LOAD 0
PUSH_CONST 5
PUSH_CONST 4
CALL 1          ; set(arr, 0, 10)

LOAD 0
PUSH_CONST 3
CALL 2          ; add(arr, 4)

LOAD 0
PUSH_CONST 0
CALL 3          ; print(get(arr, 1))

LOAD 0
PUSH_CONST 0
CALL 4          ; remove(arr, 1)

LOAD 0
PUSH_CONST 5
CALL 3          ; get(arr, 0)
LOAD 0
PUSH_CONST 0
CALL 3          ; get(arr, 1)
ADD
STORE 1

PUSH_CONST 8
LOAD 1
TO_STRING
CALL 5          ; write_file("out.txt", to_string(total))

RETURN

; main
PUSH_CONST 0
PUSH_CONST 1
PUSH_CONST 2
BUILD_ARR 3
STORE 0

LOAD 0
CALL 6          ; processAndSave(arr)

PUSH_CONST 6
PUSH_CONST 7
REM
CALL 0          ; print(17 % 5)

PUSH_CONST 8
CALL 7          ; print(read_file("out.txt"))

RETURN
```

**Бинарный код**
```kt

```

#### Пример №4
**Код UMKA**
```kt
class Cat {
    let name = "Aboba";
}

method Cat say_hello(self) -> unit {
    print(self:name + " says: Meow!");
    return;
}

fun main() -> unit {
    let my_cat = Cat;
    my_cat$say_hello();
    return;
}
```
**Текстовый байткод (с метками)**
```kt
;main
PUSH_CONST 0      ; class_id для Cat
PUSH_CONST 1      ; "Aboba" (дефолтное значение name)
BUILD_ARR 2       ; создаем объект [class_id, name]
STORE 0           ; сохраняем в переменную my_cat (индекс 0)

LOAD 0           
CALL_METHOD 0     ; say_hello (method_id=0)

PUSH_CONST 3     
RETURN

;say_hello
LOAD 0            
GET_FIELD 0       
PUSH_CONST 2     
ADD               
CALL 9223372036854775807  ;  print
PUSH_CONST 3      
RETURN           
```
**Бинарный код**
```kt

```

## 6. Стековая машина и память 
#### Стековая машина
* Все операции выполняются над данными, размещенными на стеке
* Операнды для инструкций (арифметики, сравнений, вызовов) берутся с вершины стека
* Результаты операций помещаются обратно на стек
* Аргументы функций передаются через стек
* Управление потоком (циклы, условия) использует стек для хранения состояний

#### Переменные и типы
* Все переменные выделяются на куче (heap)
* Примитивные типы: `int`, `float`, `bool`, `string`являются значимыми типами (value types).
* Массив `[]` является ссылочным типом (reference type).
* Сборка мусора автоматически освобождает неиспользуемую память


#### Функции и аргументы
* Аргументы функции берутся со стека
* На каждую функцию создается новый скоуп
* Возвращаемые значения помещаются на стек
* Локальные переменные уничтожаются при выходе из скоупа

## 7. Сборка мусора

Используется алгоритм **Mark-and-Sweep**:

1. **Mark** - пометка достижимых объектов из стека и глобальных переменных
2. **Sweep** - очистка непомеченных объектов

**Назначение:** Автоматическое управление памятью программы без участия пользователя.

**Процесс обработки:**

- Сборщик отслеживает общий объем выделенной памяти в куче (`bytes_allocated`).  При каждом выделении памяти проверяется, превышает ли прирост памяти после последней сборки порог `GC_THRESHOLD`.
- При превышении порога запускается алгоритм **Mark-and-Sweep**:
  - находит все объекты, до которых можно добраться из текущего состояния программы (стек операндов, стек вызовов, локальные переменные) и помечает их как "живые";
  - проходит по всей куче и удаляет непомеченные объекты, освобождая память.
- На время работы GC выполнение байткода приостанавливается (**stop-the-world**), затем программа продолжает работу с очищенной памятью.


## 8. JIT-компиляция

Динамическая компиляция "горячего" кода во время выполнения программы. Также анализирует прошедшие
инструкции и добавляет упрощения, которые сыграют свою роль в случае повторного вызова инструкции.

### Оптимизации

* **Свертка констант (Constant Folding)** - Вычисление выражений, состоящих из констант.
* **Loop Unrolling** - Увеличение тела цикла за счет уменьшения количества итераций. Уменьшает
  накладные расходы на проверку условия и обновление счетчика цикла.
* **Dead Code Elimination** - если результат функции не используется, его можно не считать
* **Inlining** - Короткие функции можно вызывать прямо в инструкции, вместо call вставлять сразу
  инструкции функции.
* **Tail-Call Optimization** Если функция рекурсивно вызывает саму себя в хвосте,
  JIT может заменить рекурсивный вызов на переход (jump), не создавая новый стековый фрейм.

### Возможные оптимизации

* **Common Subexpression Elimination (CSE)** Для чистых функций (те, которые не принимают ссылочные
  типы/принимают их и не изменяют, а также не имеют в себе глобальных констант) можно запоминать
  значение вычисленной функции и выдавать их, не пересчитывая.

## 9. Встроенные функции

### Основные функции ввода-вывода

#### `print(значение)`
Выводит значение в консоль.

**Параметры:**
- `значение` - Любое значение (число, строка, массив и т.д.)

**Пример:**
```kt
print("Hello, UMKA fans!")  // Выведет: Hello, UMKA fans!
print(42)            // Выведет: 42
```

#### `write(файл, содержимое)`
Записывает содержимое в файл.

**Параметры:**
- `файл` - Путь к файлу (строка)
- `содержимое` - Строка для записи

**Пример:**
```kt
write("log.txt", "Произошла ошибка")
```

#### `read(файл)`
Читает файл и возвращает его строки как массив.

**Параметры:**
- `файл` - Путь к файлу (строка)

**Возвращает:**
Массив строк (каждая строка - элемент массива)

**Пример:**
```kt
let lines = read("data.txt")
print(lines[0])  // Выведет первую строку
```

#### `input()`
Читает строку из стандартного потока ввода.

**Возвращает:**
Строку, введенную пользователем

**Пример:**
```kt
let name = input()
print("Hello, " + name)
```

### Операции с массивами

#### `len(массив)`
Возвращает длину массива.

**Параметры:**
- `массив` - Любой массив

**Возвращает:**
Число (длина массива)

**Пример:**
```kt
let arr = [1, 2, 3]
print(len(arr))  // Выведет: 3
```

#### `add_elem(массив, элемент)`
Добавляет элемент в конец массива.

**Параметры:**
- `массив` - Целевой массив
- `элемент` - Добавляемое значение

**Пример:**
```kt
let arr = []
add_elem(arr, "new element") // arr = ["new element"]
```

#### `get(массив, индекс)`
Получает элемент массива по индексу.

**Параметры:**
- `массив` - Исходный массив
- `индекс` - Позиция (начинается с 0)

**Возвращает:**
Элемент на указанной позиции

**Пример:**
```kt
let arr = [1, 2, 3]
let elem = get(arr, 0) // elem = 1
```

#### `set(массив, индекс, значение)`
Устанавливает значение элемента массива.

**Параметры:**
- `массив` - Целевой массив
- `индекс` - Позиция (начинается с 0)
- `значение` - Новое значение

**Пример:**
```kt
let arr = [1, 2, 3]
set(arr, 0, "5") // arr = [5, 2, 3]
```

#### `remove(массив, индекс)`
Удаляет элемент по индексу и сдвигает остальные.

**Параметры:**
- `массив` - Целевой массив
- `индекс` - Позиция для удаления (начинается с 0)

**Пример:**
```kt
let arr = [1, 2, 3]
remove(arr, 1)  // Удаляет второй элемент -> arr = [1, 3]
```

### Операции с массивами
#### `assert(условие)`
Проверяет условие и выбрасывает исключение, если оно ложно.

**Параметры**
- `условие` - Логическое условие

**Пример**
```kt
let x = 100
assert(x > 0)  // Ничего не происходит
assert(x < 0)  // Выбрасывается исключение: Assertion failed
```

#### `random()`
Возращает случайное число в диапазоне [0; 1).

**Возвращает**
Случайное число с плавающей точкой

**Пример**
```kt
let r = random()
print(r)  // Выведет случайное число, например: 0.548813
```

### Примечания
- Индексы массивов начинаются с 0
- Пути к файлам указываются относительно программы
- Ошибки прерывают выполнение программы

## 10. Примеры программ

#### Факториал

```kt
fun factorial_tail(n, acc) -> int {
  if (n < 2) {
    return acc;
  }
  return factorial_tail(n - 1, acc * n);
}

let result = factorial (10);
print(result); // 3628800
```

#### Сортировка массивов

* *Пузырьком*

```kt
fun sort(arr) -> [] {
    let n = len(arr);
    for (let i = 0; i < n; i = i + 1) {
    for (let j = 0; j < n - i - 1; j = j + 1) {
    if (get(arr, j) > get(arr, j + 1)) {
        let temp = get (arr, j);
        set(arr, j, get(arr, j + 1));
        set(arr, j + 1, temp);
    }
}
}
    return arr;
}
```

#### Решето Эратосфена

```kt
fun primes(limit) -> [] {
    let sieve = [];
    let result = [];
    
    for (let i = 0; i <= limit; i = i + 1) {
    add(sieve, true);
}

    for (let i = 2; i <= limit; i = i + 1) {
    if (get(sieve, i)) {
        add(result, i);
        let j = i * i;
        while (j <= limit) {
            set(sieve, j, false);
            j = j + i;
        }
    }
}

    return result;
}
```

#### Массивы

```kt
let arr =[1, 2, 3, "string", ["aboba", 1]]     // гетерогенный массив
remove(arr, 1);
add(arr, 4);
set(arr, 0, "cringe");
```

## 11. Поведение языка (ошибки)
### Классы ошибок
#### Синтаксические ошибки `SyntaxError`
* `UnexpectedToken` - последовательность токенов не удовлетворяет грамматике языка

#### Ошибка компиляции `CompilationError`
* `UndefinedIdentifier` - обращение к необъявленному идентификатору
* `NotEnoughArguments` - недостаточно аргументов для вызова функции

#### Ошибка выполнения `RuntimeError`
* `DivisionByZero` - деление на ноль
* `IndexOutOfBounds` - обращение к несуществующему индексу массива
* `IOError` - ошибка ввода-вывода
* `TypeError` - ошибка приведения типа
* `InvalidArgument` - нарушено предусловие функции

[TODO доработать]


----
Команда ЮМКА \
Юлия Кулакова, Мария Герилович, Катерина Берендюгина, Аврора Степанюк 
