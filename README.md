# UMKA 
  Минималистичный императивный язык программирования со статической типизацией, включающий виртуальную машину со сборщиком мусора и JIT-компилятором.

## Особенности

- **Простой синтаксис** - легкий для разбора и понимания
- **Стековая виртуальная машина** - эффективная байткод-интерпретация
- **Автоматическое управление памятью** - сборщик мусора Mark-and-Sweep
- **JIT-компиляция** - оптимизация "горячего" кода во время выполнения

## 1. Составляющие:

#### **UMKA-P** - Парсер
**Назначение:** Преобразование исходного кода в структурированное представление

**Процесс обработки:**
- Получает на вход текстовый файл с исходным кодом на языке UMKA
- Разбивает текст программы на базовые элементы (токены) - ключевые слова, идентификаторы, числа, операторы
- Строит древовидную структуру (AST) согласно грамматическим правилам языка
- Проверяет семантическую корректность: соответствие типов, область видимости переменных
- Выдает готовое абстрактное синтаксическое дерево для дальнейшей компиляции

#### **UMKA-C** - Компилятор
**Назначение:** Трансляция структурированного представления в исполняемый байткод

**Процесс обработки:**
- Получает на вход абстрактное синтаксическое дерево от парсера
- Преобразует дерево в последовательность низкоуровневых инструкций байткода
- Выполняет статические оптимизации: удаление неиспользуемого кода [??]ля отладки и работы системы управления памятью
- Формирует готовый байткод для выполнения в виртуальной машине

#### **UMKA-VM** - Виртуальная машина
**Назначение:** Выполнение скомпилированного байткода программы

**Процесс обработки:**
- Получает на вход байткод от компилятора
- Интерпретирует инструкции байткода последовательно, эмулируя работу процессора
- Управляет памятью программы: выделение и освобождение объектов в куче
- Реализация автоматического управления памятью посредством сборщика муссора (Garbage Collector)
- Собирает статистику выполнения для идентификации часто используемых участков кода
- Обеспечивает выполнение встроенных функций

#### **UMKA-JIT** - JIT-компилятор
**Назначение:** Динамическая компиляция "горячих" участков кода в машинный код

**Процесс обработки:**
- Анализирует статистику выполнения, собираемую виртуальной машиной
- Выявляет часто выполняемые функции и циклы для оптимизации
- Преобразует байткод в промежуточное представление, удобное для анализа
- Применяет серию оптимизаций к промежуточному представлению
- Генерирует высокоэффективный машинный код для идентифицированных участков
- Обеспечивает переход на выполнение сгенерированного машинного кода

 
## 2. Типы данных
| Тип | Описание | Пример |
|-----|-----------|---------|
| `int` | Целое число (64-битное) | `42`, `-10`, `0` |
| `double` | Дробное число (64-битное) | `2.8`, `-1.118` |
| `string` | Строка UTF-8 | `"hello"`, `"test"` |
| `bool` | Логический тип | `true`, `false` |
| `[]` | Массив элементов | `[1, 2, "a"]`, `["a", [1, 2, 3]]` |
| `void` | Отсутствие значения | `return;` |

## 3. Синтаксис
#### 3.1 Переменные
```
let x = 10;
let text = "hello";
let flag = true;
let arr = [1, 2, 3];
```

#### 3.2 Присваивание
```
x = 28;
name = "aboba";
arr[0] = 14;
```

#### 3.3 Арифметика
```
let add = 5 + 3;   // сложение
let diff = 8 - 2;  // вычитание
let mult = 6 * 8;  // умножение
let div = 4 / 2;   // деление
let mod = 17 % 5;  // взятие остатка
```

#### 3.4 Сравнения
```
let x = 10 > 5;        // true
let y = 10 == 10;      // true  
var z = "hi" != "bye"; // true
```

#### 3.5 Условные операторы
```
if (x > 10) {
    print("ok");
} else {
    print("not ok");
}
```

#### 3.6 Циклы
```
let i = 0;
while (i < 3) {
    print(i);
    i = i + 1;
}

for (let j = 0; j < 3; j = j + 1) {
    print(j);
}
```

#### 3.7 Массивы
```
let arr = [1, 2, 4];
arr = add(arr, 5);
for (let i = 0; i < len(arr); i = i + 1) {
    print(get(arr, i));
}
arr = remove(arr, 1);
```

#### 3.8 Функции
```
fun fib(n) -> int {
    if (n <= 1) {
        return 0;
    }
    return fib(n - 1) + fib(n - 2);
}
```

#### 3.9 Встроенные функции
```
print("aboba")                  // вывод в консоль
let arr_length = len(arr);      // взятие длины
arr = add(arr, elem);           // добавление в массив
arr = remove(arr, elem);        // удаление из массива
let elem = get(arr, index);     // получение из массива
let s = str(123);               // конвертация в строку
write("filename", s);           // запись в файл
let lines = read("filename");   // чтение из файла
```


#### 3.10 Комментарии
```
// using double slash
```

#### 3.11 Список зарезервированных слов
* `let` - объявление переменной
* `fun` - объявление функции
* `if` - условный оператор
* `else` - альтернатива условным оператору
* `while` - цикл while
* `for` - цикл for
* `return` - возврат из функции
* `print` - вывод в консоль
* `read` - чтение из файла
* `write` - запись в файл
* `len` - взятие длины массива
* `get` - получение из массива по индексу
* `add` - добавление в массив
* `remove` - удаление из массива
* `str` - конвертация в строку

## 4. Грамматика EBNF
[ДОБАВИТЬ как появится!!]

## 5. Байткод
Виртуальная машина использует стековую архитектуру. Основные инструкции:
#### Константы
* `PUSH value` - поместить значение на стек 
* 

#### Арифметика
* `ADD`, `SUB`, `MUL`, `DIV`, `MOD` - арифметические операции

#### Сравнения
* `EQ`, `NEQ`, `GT`, `LT`, `GTE`, `LTE` - операции сравнения

#### Переменные 
* `STORE name` - сохранить значение в переменную
* `LOAD name` - загрузить переменную на стек

#### Управление потоком
* `JMP offset` - безусловный переход
* `JMP_IF_FALSE offset` - условный переход если `false`
* `CALL arg_count` - вызов функции
* `RETURN` - возврат из функции

#### Массивы
* `BUILD_ARR size` - создать массив
* `LOAD_INDEX` - загрузить элемент по индексу
* `STORE_INDEX` - сохранить элемент по индексу

[TODO: описать принцип составления байткода и его примеры]

## 6. Сборка мусора
Используется алгоритм **Mark-and-Sweep**:
1. **Mark** - пометка достижимых объектов из стека и глобальных переменных
2. **Sweep** - очистка непомеченных объектов

[TODO: хочется больше описать стековую машину]

## 7. JIT-компиляция
[Принципы доописать тут] \
Динамическая компиляция "горячего" кода во время выполнения программы. При превышении порога вызовов функции, ее байткод транслируется в промежуточное представление, оптимизируется и компилируется в машинный код для последующего прямого выполнения на процессоре.
### Оптимизации
* **Свертка констант (Constant Folding)** -  Вычисление выражений, состоящих из констант, на этапе компиляции. Например, выражение `3 + 5 * 2` заменяется на `13`.
* **Loop Unrolling** - Увеличение тела цикла за счет уменьшения количества итераций. Уменьшает накладные расходы на проверку условия и обновление счетчика цикла.
### IR
[добавить!!!]

## 8. Примеры программ
#### Факториал
```
fun factorial(n) -> int {
    if (n < 2) {
        return 1;
    }
    return n * factorial(n - 1);
}

let result = factorial(10);
print(result);  // 3628800
```

#### Сортировка массивов
* *Пузырьком*
```
fun sort(arr) -> int {
    let n = len(arr);
    for (let i = 0; i < n; i = i + 1) {
        for (let j = 0; j < n - i - 1; j = j + 1) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}
```

#### Решето Эратосфена
```
fun primes(limit) -> int {
    let sieve = [];
    let result = [];
    
    for (let i = 0; i <= limit; i = i + 1) {
        sieve = sieve + [true];
    }
    
    for (let i = 2; i <= limit; i = i + 1) {
        if (sieve[i]) {
            result  = result + [i]
            var j = i * i;
            while (j <= limit) {
                sieve[j] = false;
                j = j + i;
            }
        }
    }
    
    return result;
}
```

[TODO добавить shitty примеров]


----
Юлия Кулакова, Мария Герилович, Катерина Берендюгина, Аврора Степанюк
