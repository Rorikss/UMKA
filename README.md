# UMKA 
  Минималистичный императивный язык программирования со статической типизацией, включающий виртуальную машину со сборщиком мусора и JIT-компилятором.

## Особенности

- **Простой синтаксис** - легкий для разбора и понимания
- **Стековая виртуальная машина** - эффективная байткод-интерпретация
- **Автоматическое управление памятью** - сборщик мусора Mark-and-Sweep
- **JIT-компиляция** - оптимизация "горячего" кода во время выполнения
- **Статическая типизация** - проверка типов на этапе компиляции

## 1. Составляющие:
* **UMKA-P** - парсер
    * описание этапов
* **UMKA-C** - компилятор
    * описание
* **UMKA-VM** - виртуальная машина
    * описание
* **UMKA-JIT** - JIT-компилятор с оптимизациями
    1. **Профилирование** - подсчет вызовов функций в интерпретаторе
    2. **Трансляция в IR** - преобразование байткода в промежуточное представление
    3. **Оптимизации**
 
## 2. Типы данных
| Тип | Описание | Пример |
|-----|-----------|---------|
| `int` | Целое число (64-битное) | `42`, `-10`, `0` |
| `double` | Дробное число (64-битное) | `2.8`, `-1.118` |
| `string` | Строка UTF-8 | `"hello"`, `"test"` |
| `bool` | Логический тип | `true`, `false` |
| `[T]` | Массив элементов типа T | `[1, 2, 3]`, `["a", "b"]` |
| `void` | Отсутствие значения | `return;` |

## 3. Синтаксис
#### 3.1 Переменные
```
let x = 10;
let text = "hello";
let flag = true;
let arr = [1, 2, 3];
```

#### 3.2 Присваивание
```
x = 28;
name = "aboba";
arr[0] = 14;
```

#### 3.3 Арифметика
```
let add = 5 + 3;   // сложение
let diff = 8 - 2;  // вычитание
let mult = 6 * 8;  // умножение
let div = 4 / 2;   // деление
let mod = 17 % 5;  // взятие остатка
```

#### 3.4 Сравнения
```
let x = 10 > 5;        // true
let y = 10 == 10;      // true  
var z = "hi" != "bye"; // true
```

#### 3.5 Условные операторы
```
if (x > 10) {
    print("ok");
} else {
    print("not ok");
}
```

#### 3.6 Циклы
```
let i = 0;
while (i < 3) {
    print(i);
    i = i + 1;
}

for (let j = 0; j < 3; ++j) {
    print(j);
}
```

#### 3.7 Массивы
```
let arr = [1, 2, 4];
arr = arr + [5];
let another_arr = [7, 8];
arr = arr + another_arr;
```

#### 3.8 Функции
```
fun fib(n) -> int {
    if (n <= 1) {
        return 0;
    }
    return fib(n - 1) + fib(n - 2);
}
```

#### 3.9 Встроенные функции
```
print("aboba")                // вывод в консоль
let arr_length = len(arr);    // взятие длины
let s = str(123);             // конвертация в строку
write("filename", s);         // запись в файл
let lines = read("filename"); // чтение из файла
```


#### 3.10 Комментарии
```
// using double slash
```

## 4. Грамматика EBNF
[ДОБАВИТЬ!!]

## 5. Байткод
Виртуальная машина использует стековую архитектуру. Основные инструкции:
#### Константы
* `PUSH value` - поместить значение на стек 
* 

#### Арифметика
* `ADD`, `SUB`, `MUL`, `DIV`, `MOD` - арифметические операции

#### Сравнения
* `EQ`, `NEQ`, `GT`, `LT`, `GTE`, `LTE` - операции сравнения

#### Переменные 
* `STORE name` - сохранить значение в переменную
* `LOAD name` - загрузить переменную на стек

#### Управление потоком
* `JMP offset` - безусловный переход
* `JMP_IF_FALSE offset` - условный переход если `false`
* `CALL arg_count` - вызов функции
* `RETURN` - возврат из функции

#### Массивы
* `BUILD_ARR size` - создать массив
* `LOAD_INDEX` - загрузить элемент по индексу
* `STORE_INDEX` - сохранить элемент по индексу

## 6. Сборка мусора
Используется алгоритм **Mark-and-Sweep**:
1. **Mark** - пометка достижимых объектов из стека и глобальных переменных
2. **Sweep** - очистка непомеченных объектов


## JIT-компиляция
[Принципы описать тут]
### Оптимизации

### IR

## Примеры программ
