# UMKA 
  Минималистичный императивный язык программирования со статической типизацией, включающий виртуальную машину со сборщиком мусора и JIT-компилятором.

## Особенности

- **Простой синтаксис** - легкий для разбора и понимания
- **Стековая виртуальная машина** - эффективная байткод-интерпретация
- **Автоматическое управление памятью** - сборщик мусора Mark-and-Sweep
- **JIT-компиляция** - оптимизация "горячего" кода во время выполнения

## 1. Составляющие:

#### **UMKA-P** - Парсер
**Назначение:** Преобразование исходного кода в структурированное представление

**Процесс обработки:**
- Получает на вход текстовый файл с исходным кодом на языке UMKA
- Разбивает текст программы на базовые элементы (токены) - ключевые слова, идентификаторы, числа, операторы
- Строит древовидную структуру (AST) согласно грамматическим правилам языка
- Проверяет семантическую корректность: соответствие типов, область видимости переменных
- Выдает готовое абстрактное синтаксическое дерево для дальнейшей компиляции

#### **UMKA-C** - Компилятор
**Назначение:** Трансляция структурированного представления в исполняемый байткод

**Процесс обработки:**
- Получает на вход абстрактное синтаксическое дерево от парсера
- Преобразует дерево в последовательность низкоуровневых инструкций байткода
- Выполняет статические оптимизации: удаление неиспользуемого кода [??]ля отладки и работы системы управления памятью
- Формирует готовый байткод для выполнения в виртуальной машине

#### **UMKA-VM** - Виртуальная машина
**Назначение:** Выполнение скомпилированного байткода программы

**Процесс обработки:**
- Получает на вход байткод от компилятора
- Интерпретирует инструкции байткода последовательно, эмулируя работу процессора
- Управляет памятью программы: выделение и освобождение объектов в куче
- Реализация автоматического управления памятью посредством сборщика муссора (Garbage Collector)
- Собирает статистику выполнения для идентификации часто используемых участков кода
- Обеспечивает выполнение встроенных функций

#### **UMKA-JIT** - JIT-компилятор
**Назначение:** Динамическая компиляция "горячих" участков кода в машинный код

**Процесс обработки:**
- Анализирует статистику выполнения, собираемую виртуальной машиной
- Выявляет часто выполняемые функции и циклы для оптимизации
- Преобразует байткод в промежуточное представление, удобное для анализа
- Применяет серию оптимизаций к промежуточному представлению
- Генерирует высокоэффективный машинный код для идентифицированных участков
- Обеспечивает переход на выполнение сгенерированного машинного кода

 
## 2. Типы данных
| Тип | Описание | Пример |
|-----|-----------|---------|
| `int` | Целое число (64-битное) | `42`, `-10`, `0` |
| `double` | Дробное число (64-битное) | `2.8`, `-1.118` |
| `string` | Строка UTF-8 | `"hello"`, `"test"` |
| `bool` | Логический тип | `true`, `false` |
| `[]` | Массив элементов | `[1, 2, "a"]`, `["a", [1, 2, 3]]` |
| `void` | Отсутствие значения | `return;` |

## 3. Синтаксис
#### 3.1 Переменные
```
let x = 10;
let text = "hello";
let flag = true;
let arr = [1, 2, 3];
```

#### 3.2 Присваивание
```
x = 28;
name = "aboba";
arr[0] = 14;
```

#### 3.3 Арифметика
```
let add = 5 + 3;   // сложение
let diff = 8 - 2;  // вычитание
let mult = 6 * 8;  // умножение
let div = 4 / 2;   // деление
let mod = 17 % 5;  // взятие остатка
```

#### 3.4 Сравнения
```
let x = 10 > 5;                 // true
let y = 10 == 10;               // true  
let z = "hi" != "bye";          // true
let w = [1, 2, 3] == [1, 2, 3]; // true
```

#### 3.5 Логические операции
```
let x = true && false;  // false
let y = true || false;  // true
let z = !true;          // false
```

#### 3.6 Условные операторы
```
if (x > 10) {
    print("ok");
} else {
    print("not ok");
}
```

#### 3.7 Циклы
```
let i = 0;
while (i < 3) {
    print(i);
    i = i + 1;
}

for (let j = 0; j < 3; j = j + 1) {
    print(j);
}
```

#### 3.8 Массивы
```
let arr = [1, 2, 4];
add(arr, 5);
for (let i = 0; i < len(arr); i = i + 1) {
    print(get(arr, i));
}
remove(arr, 1);
set(arr, 0, 10);
```

#### 3.9 Функции
```
fun fib(n) -> int {
    if (n <= 1) {
        return 0;
    }
    return fib(n - 1) + fib(n - 2);
}
```

#### 3.10 Встроенные функции
```
print("aboba")                  // вывод в консоль
let arr_length = len(arr);      // взятие длины
add(arr, elem);                 // добавление в массив
remove(arr, index);             // удаление из массива
let elem = get(arr, index);     // получение из массива
set(arr, index, elem);          // установка в массив по индексу
let s = str(123);               // конвертация в строку
write("filename", s);           // запись в файл
let lines = read("filename");   // чтение из файла
```


#### 3.11 Комментарии
```
// using double slash
```

#### 3.12 Список зарезервированных слов
* `let` - объявление переменной
* `fun` - объявление функции
* `if` - условный оператор
* `else` - альтернатива условным оператору
* `while` - цикл while
* `for` - цикл for
* `return` - возврат из функции
* `print` - вывод в консоль
* `read` - чтение из файла
* `write` - запись в файл
* `len` - взятие длины массива
* `get` - получение из массива по индексу
* `set` - смена значения в массиве по индексу
* `add` - добавление в массив
* `remove` - удаление из массива по индексу
* `str` - конвертация в строку

## 4. Грамматика EBNF
[ДОБАВИТЬ как появится!!]

## 5. Байткод
Виртуальная машина использует стековую архитектуру. Основные инструкции:
#### Константы
* `PUSH value` - поместить значение на стек 
* 

#### Арифметика
* `ADD`, `SUB`, `MUL`, `DIV`, `MOD` - арифметические операции

#### Сравнения
* `EQ`, `NEQ`, `GT`, `LT`, `GTE`, `LTE` - операции сравнения

#### Переменные 
* `STORE name` - сохранить значение в переменную
* `LOAD name` - загрузить переменную на стек

#### Управление потоком
* `JMP offset` - безусловный переход
* `JMP_IF_FALSE offset` - условный переход если `false`
* `CALL arg_count` - вызов функции
* `RETURN` - возврат из функции

#### Массивы
* `BUILD_ARR size` - создать массив
* `LOAD_INDEX` - загрузить элемент по индексу
* `STORE_INDEX` - сохранить элемент по индексу

[TODO: описать принцип составления байткода и его примеры]

## 6. Стековая машина и память 
#### Стековая машина
* Все операции выполняются над данными, размещенными на стеке
* Операнды для инструкций (арифметики, сравнений, вызовов) берутся с вершины стека
* Результаты операций помещаются обратно на стек
* Аргументы функций передаются через стек
* Управление потоком (циклы, условия) использует стек для хранения состояний

#### Переменные и типы
* Все переменные выделяются на куче (heap)
* Примитивные типы: `int`, `float`, `bool`, `string`являются значимыми типами (value types).
* Массив `[]` является ссылочным типом (reference type).
* Сборка мусора автоматически освобождает неиспользуемую память


#### Функции и аргументы
* Аргументы функции берутся со стека
* На каждую функцию создается новый скоуп
* Возвращаемые значения помещаются на стек
* Локальные переменные уничтожаются при выходе из скоупа

## 7. Сборка мусора
Используется алгоритм **Mark-and-Sweep**:
1. **Mark** - пометка достижимых объектов из стека и глобальных переменных
2. **Sweep** - очистка непомеченных объектов

[TODO: описать алгоритм и стратегию работы]

## 8. JIT-компиляция
[Принципы доописать тут] \
Динамическая компиляция "горячего" кода во время выполнения программы. При превышении порога вызовов функции, ее байткод транслируется в промежуточное представление, оптимизируется и компилируется в машинный код для последующего прямого выполнения на процессоре.
### Оптимизации
* **Свертка констант (Constant Folding)** -  Вычисление выражений, состоящих из констант, на этапе компиляции. Например, выражение `3 + 5 * 2` заменяется на `13`.
* **Loop Unrolling** - Увеличение тела цикла за счет уменьшения количества итераций. Уменьшает накладные расходы на проверку условия и обновление счетчика цикла.
### IR
[добавить!!!]

## 9. Встроенные фунукции
[TODO добавить доку по ним: что принимают, что возвращают, как устроены]

## 10. Примеры программ
#### Факториал
```kt
fun factorial(n) -> int {
    if (n < 2) {
        return 1;
    }
    return n * factorial(n - 1);
}

let result = factorial(10);
print(result);  // 3628800
```

#### Сортировка массивов
* *Пузырьком*
```kt
fun sort(arr) -> [] {
    let n = len(arr);
    for (let i = 0; i < n; i = i + 1) {
        for (let j = 0; j < n - i - 1; j = j + 1) {
            if (get(arr, j) > get(arr, j + 1)) {
                let temp = get(arr, j);
                set(arr, j, get(arr, j + 1));
                set(arr, j + 1, temp);
            }
        }
    }
    return arr;
}
```

#### Решето Эратосфена
```kt
fun primes(limit) -> [] {
    let sieve = [];
    let result = [];
    
    for (let i = 0; i <= limit; i = i + 1) {
        add(sieve, true);
    }
    
    for (let i = 2; i <= limit; i = i + 1) {
        if (get(sieve, i)) {
            add(result, i);
            let j = i * i;
            while (j <= limit) {
                set(sieve, j, false);
                j = j + i;
            }
        }
    }
    
    return result;
}
```

#### Массивы
```kt
let arr = [1, 2, 3, "string", ["aboba", 1]]     // гетерогенный массив
remove(arr, 1);
add(arr, 4);
set(arr, 0, "cringe");
```

[TODO добавить shitty примеров]

## 11. Поведение языка (ошибки)
### Классы ошибок
#### Синтаксические ошибки `SyntaxError`
* `UnexpectedToken` - последовательность токенов не удовлетворяет грамматике языка

#### Ошибка компиляции `CompilationError`
* `UndefinedIdentifier` - обращение к необъявленному идентификатору
* `NotEnoughArguments` - недостаточно аргументов для вызова функции

#### Ошибка выполнения `RuntimeError`
* `DivisionByZero` - деление на ноль
* `IndexOutOfBounds` - обращение к несуществующему индексу массива
* `IOError` - ошибка ввода-вывода
* `TypeError` - ошибка приведения типа
* `InvalidArgument` - нарушено предусловие функции

[TODO доработать]


----
команда ЮМКА \
Юлия Кулакова, Мария Герилович, Катерина Берендюгина, Аврора Степанюк 
