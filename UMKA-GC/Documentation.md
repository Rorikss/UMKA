## Описание Garbage Collector

### Используется алгоритм Mark and sweep
1. Mark (Пометка): Начинаем с "корней" и помечаем все объекты, до которых можно добраться. Эти объекты - "живые".

2. Sweep (Очистка): Проходим по всей куче и освобождаем память, занятую непомеченными объектами.

### Когда запускаем
1. У нас есть счетчик общего обьема выделенной памяти (bytes_allocated). Он увеличивается с каждой операцией, которая выделяет память
   - увеличивать на sizeof(Entity)
   - для массива map.size() * sizeof(pair<int, Reference<Entity>>)
2. У нас есть лимит (GC_THRESHOLD = total_available_ram_bytes * GC_PERCENT;). Если (bytes_allocated) > (GC_THRESHOLD), то запускаем наш gc  
GC_PERCENT = 25%
### Stop the world  
На время работы GC выполнение кода ВМ останавливается. После того как GC завершит свою работу и он освободил достаточно памяти, то ВМ сможет продолжить работу


### Mark
Цель: пометить все достижимые (живые) обьекты
1. Для каждого обьекта в куче добавим поле is_marked (Будет отдельно структура типа лист или мапа или класс (потом напишу здесь), или отдельно где храним обьект и маркер, т.о не меняем Entity)
2. Перед началом пометки все флаги false (сброшены). Помечаем все false
3. Необходимы корни (Roots). С них и начинаем помечать
   - стек операндов. Все Reference<Entity> в стеке операндов (operand_stack)
   - stackFrame = function frame 
   - стек вызовов ВМ. Сборщик мусора должен обходить весь name_resolver каждой функции в стеке вызовов

4. Рекурсивно обходим граф обьектов.
    - Если указатель на обьект в куче еще не был помечен - помечаем его  
    - Особый случай: массивы (std::map<int, Reference<Entity>>), нужно рекурсивно обойти все элементы массива

Т.о мы обойдем весь граф достижимых обьектов и они будут помечены как достижимые (is_marked = true)

### Sweep
Цель: проходим по всей куче и освобождаем, что было не отмечено как достижимый обьект
1. Иду по списку всех обьектов (heap)
2. Если обьект отмечен (is_marked = true) - он живой (его не трогаем).
3. Если обьект не отмечен (is_marked = false) - он мертв (его трогаем). Удаляем из списка всех обьектов, освобождаем память, уменьшаем счетчик bytes_allocate
4. Если очистка не помогла освободить столько памяти, чтобы новый обьект аллоцировался - выкидываем ошибку OutOfMemory
5. Делаем heap.shrink_to_fit()

