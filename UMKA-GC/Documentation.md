## Описание Garbage Collector

### Используется алгоритм Mark and sweep
1. Mark (Пометка): Начинаем с "корней" и помечаем все объекты, до которых можно добраться. Эти объекты - "живые".

2. Sweep (Очистка): Проходим по всей куче и освобождаем память, занятую непомеченными объектами.

### Когда запускаем
1. У нас есть счетчик общего обьема выделенной памяти (bytes_allocated). Он увеличивается с каждой операцией, которая выделяет память
   - увеличивать на sizeof(Entity)
   - для массива map.size() * sizeof(pair<int, Reference<Entity>>)
2. У нас есть лимит (GC_THRESHOLD). Если (bytes_allocated) > (GC_THRESHOLD), то запускаем наш gc
\\ TODO++++ *процент оперативки* а не константа. или по количеству
### Stop the world  
На время работы GC выполнение кода ВМ останавливается. После того как GC завершит свою работу и он освободил достаточно памяти, то ВМ сможет продолжить работу


### Mark
Цель: пометить все достижимые (живые) обьекты
помечаем все FALSE 
1. Для каждого обьекта в куче добавим поле is_marked (\\ TODO возможно отдельно какаято структура типа лист или мапа хз, или отдельно где храним обьект и маркер, т.о не меняем Entity). Перед началом пометки все флаги false (сброшены)
2. Необходимы корни (Roots). С них и начинаем помечать
   - стек операндов. Все Reference<Entity> в стеке операндов (operand_stack)
   - stackFrame = function frame 
   - стек вызовов ВМ. Сборщик мусора должен обходить весь name_resolver каждой функции в стеке вызовов (\\ TODO спросить у Авроры что у нас есть, какие именно это переменные и тп, прописать тут)

3. Рекурсивно обходим граф обьектов.
    - Если указатель на обьект в куче еще не был помечен - помечаем его  
    - Особый случай: массивы (std::map<int, Reference<Entity>>), нужно рекурсивно обойти все элементы массива

Т.о мы обойдем весь граф достижимых обьектов и они будут помечены как достижимые (is_marked = true)

### Sweep
Цель: проходим по всей куче и освобождаем, что было не отмечено как достижимый обьект
1. Иду по списку всех обьектов (heap)
2. Если обьект отмечен (is_marked = true) - он живой (его не трогаем). (нет \\ TODO возможно тут надо сразу снимать пометку, чтобы перед gc не делать всем обьектам false, хз)
3. Если обьект не отмечен (is_marked = false) - он мертв (его трогаем). Удаляем из списка всех обьектов, освобождаем память, уменьшаем счетчик bytes_allocate (не то - делаем вычисление процента!!!)
4. пошел нахуй BadAlloc) OutOfMemory \\ TODO возможно надо подумать, что если нам эта очиска не помогла освобожить столько памяти, чтобы новый обьект аллоцировался. увеличивать ли THRESHOLD_GC?
5. делаем heap.shrink_to_fit()

